var e={65:(e,t,r)=>{r.d(t,{D:()=>c,Z:()=>n});const s={},c=function(...e){e[0]instanceof Array&&(e=e[0]);for(let t in this)"use"!==t&&(e.length&&!e.includes(t)||(globalThis[t]=this[t]))}.bind(s);Object.assign(s,{use:c});const n=s}},t={};function r(s){var c=t[s];if(void 0!==c)return c.exports;var n=t[s]={exports:{}};return e[s](n,n.exports,r),n.exports}r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var s={};(()=>{r.d(s,{D$:()=>e.D,Rh:()=>n,Xh:()=>c,ZP:()=>o,oc:()=>t});var e=r(65);function t(e,t,r=this){return Object.keys(r)[e]((e=>t(r[e],e,r)))}function c(e,t,r=this){return Object.keys(r).reduce(((t,s)=>e(t,r[s],s,r)),t)}async function n(e,t,r=this){return Object.keys(r).reduce((async(t,s)=>await e(t,r[s],s,r)),t)}Object.assign(e.Z,{emulateArray:t,objectReduce:c,objectReduceAsync:n});const o=e.Z})();var c=s.ZP,n=s.oc,o=s.Xh,a=s.Rh,u=s.D$;export{c as default,n as emulateArray,o as objectReduce,a as objectReduceAsync,u as use};